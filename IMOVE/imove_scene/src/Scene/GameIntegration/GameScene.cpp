#include "GameScene.h"
#include "../../../../../game/src/control/GameManager.h"
#include "../../../../../game/src/rendering/RenderWrapper.h"
#include "../../../../../game/src/storage/InputData.h"
#include "../../../../../game/src/storage/Variables.h"
#include "../../../../../game/src/control/gameStates/GameRunningState.h"
#include <list>

/**
 * Constructor for the GameScene, this is called in SceneWindow.cpp.
 * @param config - The configuration of the scene.
 */
GameScene::GameScene(SceneConfiguration config) {
    this->sceneConfig = config;
    this->gameManager = new GameManager();
    this->renderWrapper = nullptr;
    this->users = new UserManager();

    if(!Variables::IMOVE_ACTIVE) {
        std::cout << "[WARNING] Set the IMOVE_ACTIVE variable to TRUE when running the game with IMOVE!" <<
                  std::endl;
        exit(1);
    }
}

/**
 * This propagates the input generated by the UserManager to the GameManager,
 * which in turn will be rendered through the RenderWrapper.
 * @param target - The window that the scene needs to be rendered on.
 */
void GameScene::draw(sf::RenderWindow &target) {

    Time frameTime = clock.restart();

    // Create a RenderWrapper if is has not been initialized.
    if (this->renderWrapper == nullptr) {
        this->renderWrapper = new RenderWrapper(&target);
    }

    // Generate input based on current players in the screen and send generated InputData to the GameManager.
    std::list<InputData *> inputDataList = users->generateInput(frameTime.asSeconds());

    // If there are no players are in the scene, the RenderWrapper does not get the frameTime.
    if (inputDataList.empty()) {
        auto *input = new InputData(InputData::imove);
        input->setFrameTime(frameTime.asSeconds());
        inputDataList.push_back(input);
    }

    // Check if the spacebar is pressed. Pressing the spacebar will start/restart the game.
    if (Keyboard::isKeyPressed(Keyboard::Space)) {
        inputDataList.front()->pressSpace();
    }

    // Check if K is pressed. This will kill all players, used for debugging.
    if(Keyboard::isKeyPressed(Keyboard::K)) {
        inputDataList.front()->pressK();
    }

    // Check if L is pressed. This will add a player, used for debugging.
    if(Keyboard::isKeyPressed(Keyboard::L)) {
        inputDataList.front()->pressL();
    }

    // Check if D is pressed. This will toggle the DEBUG_ACTIVE variable.
    if(Keyboard::isKeyPressed(Keyboard::J)) {
        inputDataList.front()->pressJ();
    }

    // Clear render wrapper.
    renderWrapper->clearFrame();

    //Propagate the movement data to the GameManager.
    gameManager->update(inputDataList);

    // Calls to generate / update the final scene.
    renderWrapper->renderBackground();

    // Render all game entities.
    gameManager->render(renderWrapper);

    // Update and render the animations.
    renderWrapper->updateAnimations(frameTime, &target);

    // Render debug info if DEBUG_MODE is active.
    if(Variables::DEBUG_MODE) {
        renderWrapper->renderDebugInfo(inputDataList.front());
    }

    // Display the frame and push all rendered data to the SFML window at once.
    renderWrapper->displayFrame();

    // Clear user data to prevent previous user data from IMOVE from influencing the next frame.
    users->clearData();
}


/**
 * This void method looks at all the people in the scene, and updates all users active on the field accordingly,
 * and it deletes all user that have left the playing field.
 */
void GameScene::processPeople() {
    //Check if the people have been updated.
    if (!peopleQueue.empty()) {

        // Get the PlayerManager of the GameManager to propagate newly created / deleted players.
        PlayerManager *playerManager = gameManager->getPlayerManager();

        // Pop queue of detected people from IMOVE.
        scene_interface::People newPeople = peopleQueue.front();
        peopleQueue.pop();

        for (unsigned int i = 0; i < newPeople.size(); ++i) {
            scene_interface::Person person = newPeople[i];
            unsigned int id = person.getId();
            scene_interface::Location newLocation = person.getLocation();

            // Only if the person is a participant (and is therefore located within the scene will there be a corresponding user updated or created.
            if (person.getPersonType() == scene_interface::Person::PersonType::Participant) {
                // If the person was not already in the scene and its user is not in the repository.
                if (!users->has(id)) {
                    // Create new user and assign to person's id.
                    if(playerManager != nullptr) {
                        playerManager->createPlayer(id);
                    }
                    users->add(new User(id, newLocation.getX(), newLocation.getY()));
                } else {
                    // Or update location otherwise.
                    users->get(id)->setLocation(newLocation.getX(), newLocation.getY());
                }
            } else {
                // If the person left the scene, delete their circle.
                if (users->has(id)) {
                    //And propagate this to the playerManager.
                    if(playerManager != nullptr) {
                        playerManager->destroyPlayer(id);
                    }
                    users->scheduleForRemoval(id);
                }
            }
        }
    }
    users->removeAll();
}
